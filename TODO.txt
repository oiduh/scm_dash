steps:
    - [X] simple tutorial
    - [X] simple scatter plot
        - [X] integrate pandas and numpy -> random stats
        - [X] scatter plot
    - [ ] new file: network graphs -> hardcode all options
        https://dash.plotly.com/cytoscape/styling
    - [X] new file: distributions
    - [ ] design menu
        - [ ] each node -> menu with exo + endo variable + distr sliders
            - [X] simple mechanism to combine them
            - [X] advanced mechanism to combine them
        - [X] mechanisms
            - [X] hard coded
            - [X] options
            - [X] user defined?
        - [ ] select graph network structure
            - [ ] chain
            - [ ] fork
            - [ ] collider
    

 
ideas:
    graph:
        one scatter graph -> multiple graphs for more complex examples
        marginal distribution e.g. like seaborn.jointplot
        scm as graph
    menu:
        sliders for various distributions -> flexibility -> can be more comples later
        sliders for noise
        dropdown for basic causality structures (fork, chain, collider)
        intervention option -> set to fix values
        each variable selector or each node selector needs instance of class
        tabs for each node?
        tabs for nodes/mechanisms?
        noise restrictions -> additive noise model
        label noise -> how to apply ANM to labels?

tech:
    scipy.stats -> various distributions

implementation details:
    start with fixed number of allocated variables -> know beforehand how many sliders etc.
    later it should be possible to dynamically define distributions of a variable -> could also
        be a variable consisting of multiple distributions -> clusters
    files:
        distributions.py for all distributions and their getters, configs etc.



https://community.plotly.com/t/dash-range-slider-which-able-to-interact-with-input-field-that-display-range-slider-value/49476/3

root causes very often just noise:
    chain = x -> y -> z:
        x -> noise
        y -> x + noise
        z -> y + noise
    fork = x <- y -> z:
        x -> y + noise
        y -> noise
        z -> y + noise
    collider = x -> y <- z:
        x -> noise
        y -> x + z + noise
        z -> noise

simple process design:
    1) user selects graph type -> chain, fork, collider -> 3 variables each nice to visulize
    2) user selects noise distributions -> root causes are id of noise
    3) user defines mechanism according to chosen graph type
    4) pressing 'create' button generates the data set and a simple visualization

possible features:
    1) custom graph e.g. via adjacency matrix -> needs check for circles; also automatically 
       creates the fields for exact number of mechanisms
    2) more distributions to same variable -> enables cluster formation e.g. 3 normal distributions
       with different mu's
    3) interactive intervention tool -> should be available for each variable -> changing to fixed
       value shows effects on other variables immediately
    4) more graphs e.g. correlation matrix, marginal distributions, tsne if many variables

order of implementation:
    since everything was tested -> no need to experiment
    1) choose graph type
       depending on graph type -> application of noise and mechanism -> needs definition
       provide default values and examples for instant result
    2) choose distribution
       drop down menu with many options and sliders for various distributions
       only noise
    3) adjust mechanism -> depending on intent: classification or regression -> user choice


